# Worktrunk Development Guidelines

> **Note**: This CLAUDE.md is just getting started. More guidelines will be added as patterns emerge.

## Project Status

**This project has no users yet and zero backward compatibility concerns.**

We are in **pre-release development** mode:
- Breaking changes are acceptable and expected
- No migration paths needed for config changes, API changes, or behavior changes
- Optimize for the best solution, not compatibility with previous versions
- Move fast and make bold improvements

When making decisions, prioritize:
1. **Best technical solution** over backward compatibility
2. **Clean design** over maintaining old patterns
3. **Modern conventions** over legacy approaches

Examples of acceptable breaking changes:
- Changing config file locations (e.g., moving from `~/Library/Application Support` to `~/.config`)
- Renaming commands or flags for clarity
- Changing output formats
- Replacing dependencies with better alternatives
- Restructuring the codebase

When the project reaches v1.0 or gains users, we'll adopt stability commitments. Until then, we're free to iterate rapidly.

## CLI Output Formatting Standards

### The anstyle Ecosystem

All styling uses the **anstyle ecosystem** for composable, auto-detecting terminal output:

- **`anstream`**: Auto-detecting I/O streams (println!, eprintln! macros)
- **`anstyle`**: Core styling with inline pattern `{style}text{style:#}`
- **Color detection**: Respects NO_COLOR, CLICOLOR_FORCE, TTY detection

### Message Types

Five canonical message patterns with their emojis:

1. **Progress**: üîÑ + cyan text (operations in progress)
2. **Success**: ‚úÖ + green text (successful completion)
3. **Errors**: ‚ùå + red text (failures, invalid states)
4. **Warnings**: üü° + yellow text (non-blocking issues)
5. **Hints**: üí° + dimmed text (helpful suggestions)

### stdout vs stderr: Separation by Source

**Core Principle: Separate output by who generates it, not by message type.**

- **stdout**: All output generated by worktrunk (messages, directives, data, errors, warnings, progress)
- **stderr**: All output generated by child processes (git, npm, user commands)

This creates clean semantic separation: "Is it from us or from a child process?"

**Benefits:**
- Simple reasoning: one decision point (source), not multiple (type, severity, etc.)
- No cross-stream coordination needed (no flushing stderr before stdout directives)
- Better for piping: `wt list | jq` gets clean data, `wt switch -x "npm install" 2>/dev/null` suppresses npm noise
- Child process output never interferes with our protocol (directives, structured output)

**Trade-off:**
- Violates Unix convention that errors go to stderr
- Our "errors" are structured program output (validation failures, formatted git errors), not unexpected crashes
- Panics and assertion failures still go to stderr via Rust's default handler (which is correct)

**Implementation:**
```rust
use worktrunk::styling::{println, ERROR, ERROR_EMOJI};

// ALL our output goes to stdout (including errors)
println!("{ERROR_EMOJI} {ERROR}Branch already exists{ERROR:#}");
println!("‚úÖ Created worktree");
println!("üí° Run 'wt list' to see all worktrees");
```

**Child processes:**
```rust
// Redirect child stdout to stderr so all child output goes there
let wrapped = format!("{{ {}; }} 1>&2", command);
Command::new("sh")
    .arg("-c")
    .arg(&wrapped)
    .stdout(Stdio::inherit())  // Actually goes to stderr due to redirect
    .stderr(Stdio::inherit())
    .status()?;
```

### Temporal Locality: Output Should Be Close to Operations

**Core Principle: Output should appear immediately adjacent to the operations they describe.**

Users experience commands as temporal sequences. Output that appears far from its triggering operation creates confusion and breaks the mental model of what's happening.

**The Two Patterns:**

1. **Progress ‚Üí Operation ‚Üí Success** (for sequential operations)
   ```
   üîÑ Removing worktree for feature...
   ‚úÖ Removed worktree for feature
   üîÑ Removing worktree for bugfix...
   ‚úÖ Removed worktree for bugfix
   ```

2. **Progress ‚Üí Operation ‚Üí Success ‚Üí Summary** (for complex multi-step operations)
   ```
   üîÑ Squashing 3 commits into one...
   üîÑ Generating commit message...
     [commit message display]
   ‚úÖ Squashed 3 commits into one          ‚Üê Immediate feedback
   üîÑ Rebasing onto main...
   ...
   ‚úÖ Merged feature ‚Üí main                ‚Üê Final summary
   Squashed 3 commits                      ‚Üê Context in summary
   ```

**Bad pattern - output decoupled from operations:**
```
üîÑ Removing worktree for feature...
üîÑ Removing worktree for bugfix...
üîÑ Removing worktree for hotfix...
                                          ‚Üê Long delay, no feedback
Removed worktree for feature              ‚Üê All output at the end
Removed worktree for bugfix
Removed worktree for hotfix
```

**Why this matters:**

- **Temporal locality**: Feedback appears when the action completes, not seconds/minutes later
- **User confidence**: Immediate success messages confirm each operation worked
- **Debugging**: If something fails, users know exactly which operation failed
- **Progress visibility**: Users can see what's done vs. what's still in progress
- **Interrupt recovery**: If user hits Ctrl+C, they know what completed
- **Natural mental model**: Matches how users think about sequential operations

**Implementation patterns:**

```rust
// Pattern 1: Simple sequential operations (like batch remove)
for item in items {
    // Show what we're about to do
    output::progress(format!("üîÑ {CYAN}Removing {item}...{CYAN:#}"))?;

    // Do the operation
    let result = perform_operation(item)?;

    // Show immediate success
    output::success(format!("Removed {item}"))?;
}

// Pattern 2: Complex operation with substeps
output::progress("üîÑ Starting complex operation...")?;

// Substep 1
output::progress("üîÑ Validating...")?;
validate()?;
output::success("Validated")?;

// Substep 2
output::progress("üîÑ Processing...")?;
process()?;
output::success("Processed")?;

// Final summary (optional, for context)
output::success("Completed complex operation")?;
```

**Red flags - violations of temporal locality:**

1. **Collecting messages in a buffer**: `let mut messages = Vec::new(); messages.push(...)` ‚Üí emit immediately instead
2. **Single success message for batch operations**: Loop that shows all successes at the end
3. **No progress before slow operations**: User sees nothing, then suddenly output appears
4. **Progress without matching success**: Progress messages that aren't followed by success/failure
5. **Success before operation**: Showing success message before operation completes (async timing bugs)

**Apply this to:**
- Batch operations: Show progress + success for each item in the loop
- Multi-step operations: Show success after each major step completes
- Slow operations: Show progress immediately before starting
- Error handling: Show failure immediately when detected, not collected for later

### Semantic Style Constants

**Style constants defined in `src/styling.rs`:**

- **`ERROR`**: Red (errors, conflicts)
- **`WARNING`**: Yellow (warnings)
- **`HINT`**: Dimmed (hints, secondary information)
- **`CURRENT`**: Magenta + bold (current worktree)
- **`ADDITION`**: Green (diffs, additions)
- **`DELETION`**: Red (diffs, deletions)

**Emoji constants:**

- **`ERROR_EMOJI`**: ‚ùå (use with ERROR style)
- **`WARNING_EMOJI`**: üü° (use with WARNING style)
- **`HINT_EMOJI`**: üí° (use with HINT style)

### Inline Formatting Pattern

Use anstyle's inline pattern `{style}text{style:#}` where `#` means reset:

```rust
use worktrunk::styling::{println, ERROR, ERROR_EMOJI, WARNING, WARNING_EMOJI, HINT, HINT_EMOJI, AnstyleStyle};
use anstyle::{AnsiColor, Color};

// Progress
let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
println!("üîÑ {cyan}Rebasing onto main...{cyan:#}");

// Success
let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
println!("‚úÖ {green}Pushed to main{green:#}");

// Error - ALL our output goes to stdout
println!("{ERROR_EMOJI} {ERROR}Working tree has uncommitted changes{ERROR:#}");

// Warning - ALL our output goes to stdout
println!("{WARNING_EMOJI} {WARNING}Uncommitted changes detected{WARNING:#}");

// Hint
println!("{HINT_EMOJI} {HINT}Use 'wt list' to see all worktrees{HINT:#}");
```

### Composing Styles

Compose styles using anstyle methods (`.bold()`, `.fg_color()`, etc.):

```rust
use worktrunk::styling::{println, AnstyleStyle, ERROR, WARNING};

// Error with bold branch name
let error_bold = ERROR.bold();
println!("‚ùå Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Warning with bold
let warning_bold = WARNING.bold();
println!("üü° {warning_bold}{message}{warning_bold:#}");

// Just bold (no color)
let bold = AnstyleStyle::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");
```

### Branch Name Formatting

**Always format branch names in bold** when they appear in messages:

```rust
use worktrunk::styling::{println, AnstyleStyle, ERROR};

// Good - bold branch name in error
let error_bold = ERROR.bold();
println!("‚ùå Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Good - bold in regular message
let bold = AnstyleStyle::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");

// Bad - plain branch name
println!("Switched to worktree: {branch}")
```

### Information Hierarchy & Path Styling

**Principle: Bold what answers the user's question, dim what provides context.**

Style elements based on **user intent**, not data type. The same information (like a file path) can be primary in one context and secondary in another.

**File paths:**

- **Primary information** (answering the user's main question): **Bold**
  - Example: `wt config list` - paths are the answer to "where is my config?"

- **Secondary information** (contextual metadata): **Dim**
  - Example: `wt switch` output - path provides context, branch name is the answer

```rust
use worktrunk::styling::AnstyleStyle;

// Path as primary answer (config list)
let bold = AnstyleStyle::new().bold();
println!("Global Config: {bold}{}{bold:#}", path.display());

// Path as secondary context (switch output)
let dim = AnstyleStyle::new().dimmed();
println!("‚úÖ Created {bold}{branch}{bold:#}\n  {dim}Path: {}{dim:#}", path.display());
```

**Visual hierarchy patterns:**

| Element | Primary (answers question) | Secondary (provides context) |
|---------|---------------------------|------------------------------|
| Branch names | **Bold** (always) | **Bold** (always) |
| File paths | **Bold** (`config list`) | **Dim** (`switch` output) |
| Config values | Normal | **Dim** |
| Metadata | Dim | **Dim** |

### Indentation Policy

**Core Principle: No manual indentation for secondary information.**

Styling (bold, dim, color) already provides visual hierarchy. Manual indentation adds cognitive load without adding clarity.

**Rules:**

1. **Secondary paths, metadata**: No indent, use dimmed styling only
   ```rust
   // Good - dimming provides hierarchy
   println!("‚úÖ Created {bold}{branch}{bold:#}");
   println!("{dim}Path: {}{dim:#}", path.display());

   // Bad - unnecessary indent
   println!("‚úÖ Created {bold}{branch}{bold:#}");
   println!("  {dim}Path: {}{dim:#}", path.display());
   ```

2. **File lists (bullets)**: No indent, bullet provides visual separation
   ```rust
   // Good - bullet is enough
   for file in &files {
       println!("{dim}‚Ä¢{dim:#} {}", file);
   }

   // Bad - redundant indent
   for file in &files {
       println!("  {dim}‚Ä¢{dim:#} {}", file);
   }
   ```

3. **Log file paths**: No indent, dimming is sufficient
   ```rust
   // Good
   println!("{dim}Logs: {}{dim:#}", path);

   // Bad
   println!("  {dim}Logs: {}{dim:#}", path);
   ```

4. **Quoted content (commands, config)**: Use `format_with_gutter()` instead of manual indents
   ```rust
   // Good - gutter provides visual separation
   print!("{}", format_with_gutter(&command));

   // Bad - manual indentation
   for line in command.lines() {
       println!("  {}", line);
   }
   ```

**Exception:** Nested hierarchies where structural relationships must be clear (not yet encountered in this codebase).

**Rationale:**
- Styling already creates visual hierarchy
- Indentation is redundant cognitive load
- Simpler output is easier to scan
- Follows git's own output conventions

### Color Detection

Colors automatically adjust based on environment:
- Respects `NO_COLOR` (disables)
- Respects `CLICOLOR_FORCE` / `FORCE_COLOR` (enables)
- Auto-detects TTY (colors only on terminals)

All handled automatically by `anstream` macros.

### Design Principles

- **Inline over wrappers** - Use `{style}text{style:#}` pattern, not wrapper functions
- **Composition over special cases** - Use `.bold()`, `.fg_color()`, not `format_X_with_Y()`
- **Semantic constants** - Use `ERROR`, `WARNING`, not raw colors
- **YAGNI for presentation** - Most output needs no styling
- **Minimal output** - Only use formatting where it adds clarity
- **Unicode-aware** - Width calculations respect emoji and CJK characters (via `StyledLine`)
- **Graceful degradation** - Must work without color support

### Complete Examples

```rust
use worktrunk::styling::{
    eprintln, println, AnstyleStyle,
    ERROR, ERROR_EMOJI, WARNING, WARNING_EMOJI, HINT, HINT_EMOJI
};
use anstyle::Style;

// Simple error
println!("{ERROR_EMOJI} {ERROR}Working tree has uncommitted changes{ERROR:#}");

// Error with bold branch name
let error_bold = ERROR.bold();
println!("{ERROR_EMOJI} Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Warning with bold
let warning_bold = WARNING.bold();
println!("{WARNING_EMOJI} {warning_bold}Uncommitted changes detected{warning_bold:#}");

// Hint
println!("{HINT_EMOJI} {HINT}Use 'wt list' to see all worktrees{HINT:#}");

// Bold branch name in regular message
let bold = Style::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");

// Complex multi-part error
let error_bold = ERROR.bold();
println!("{ERROR_EMOJI} Not a fast-forward from '{error_bold}{target_branch}{error_bold:#}' to HEAD");

// Dimmed secondary info
let dim = Style::new().dimmed();
println!("  {dim}Path: {path}{dim:#}");
```

### StyledLine API

For complex table formatting with proper width calculations, use `StyledLine`:

```rust
use worktrunk::styling::StyledLine;
use anstyle::{AnsiColor, Color, Style};

let mut line = StyledLine::new();
let dim = Style::new().dimmed();
let cyan = Style::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));

line.push_styled("Branch", dim);
line.push_raw("  ");
line.push_styled("main", cyan);

println!("{}", line.render());
```

See `src/commands/list/render.rs` for advanced usage.

### Gutter Formatting for Quoted Content

The **gutter** is a subtle visual separator (single space with background color) used for quoted content like commands and configuration.

**Core Principle: Gutter provides all the separation needed**

The gutter's visual distinction is sufficient - no additional indentation required. This keeps the output clean and maximizes horizontal space for content.

#### Formatting Rules

1. **Gutter at column 0**: `format_with_gutter(content)`
   - Gutter appears at column 0
   - Content appears at column 1 (after the gutter + 1 space)
   - The colored background provides visual separation from surrounding text

2. **Preserve internal structure**: Multi-line content maintains its original formatting
   - Don't strip leading whitespace that's part of the content
   - Apply gutter treatment uniformly to each line

#### Examples

**Config display:**
```
Global Config: /path/to/config
 worktree-path = "../{main-worktree}.{branch}"

 [llm]
```

**Command approval:**
```
project wants to execute:
 [ -d {repo_root}/target ] &&
 [ ! -e {worktree}/target ] &&
 cp -cR {repo_root}/target/. {worktree}/target/
```

**Command execution:**
```
üîÑ Executing (post-create):
 npm install
```

#### Implementation

```rust
use worktrunk::styling::format_with_gutter;

// Simple usage - gutter provides all separation
print!("{}", format_with_gutter(&command));
print!("{}", format_with_gutter(&config));
```

**Function signature:**
```rust
/// Arguments:
/// - content: Text to format (preserves internal structure for multi-line)
pub fn format_with_gutter(content: &str) -> String
```

## Output System Architecture

### Two Output Modes

Worktrunk supports two output modes, selected once at program startup:

1. **Interactive Mode** - Human-friendly output with colors, emojis, and hints
2. **Directive Mode** - Machine-readable NUL-terminated directives for shell integration

The mode is determined at initialization in `main()` and never changes during execution.

### The Cardinal Rule: Never Check Mode in Command Code

**CRITICAL: Command code must NEVER check which output mode is active.**

The output system uses enum dispatch with a global context. Commands call output functions (`output::success()`, `output::change_directory()`, etc.) without knowing or caring which mode is active. The output system dispatches to the appropriate handler.

**Bad - mode conditionals scattered through commands:**
```rust
// ‚ùå NEVER DO THIS
use crate::output::OutputMode;

fn some_command(mode: OutputMode) {
    if mode == OutputMode::Interactive {
        println!("‚úÖ Success!");
    } else {
        println!("Success!\0");
    }
}
```

**Good - use the output system:**
```rust
// ‚úÖ ALWAYS DO THIS
use crate::output;

fn some_command() {
    output::success("Success!")?;
    // The output system handles formatting for both modes
}
```

### How It Works

The output system implements the "trust boundaries" principle:

1. **Decide once at the edge** - `main()` determines mode from CLI flags
2. **Initialize globally** - `output::initialize(mode)` sets up the handler
3. **Trust internally** - Commands just call output functions
4. **Dispatch handles adaptation** - Enum dispatch routes to appropriate handler

```rust
// In main.rs - the only place that knows about modes
let mode = if internal {
    OutputMode::Directive
} else {
    OutputMode::Interactive
};
output::initialize(mode);

// Everywhere else - just use the output functions
output::success("Created worktree")?;
output::change_directory(&path)?;
output::execute("git pull")?;
```

### Available Output Functions

The output module (`src/output/global.rs`) provides these functions:

- `success(message)` - Emit success messages (both modes)
- `progress(message)` - Emit progress updates (interactive only, suppressed in directive)
- `change_directory(path)` - Request directory change (directive) or store for execution (interactive)
- `execute(command)` - Execute command (interactive) or emit directive (directive mode)
- `command_output(stdout, stderr)` - Display output from external commands
- `flush()` - Flush output buffers

For the complete API, see `src/output/global.rs`.

### Adding New Output Functions

When adding new output capabilities:

1. **Add the function to both handlers** - `InteractiveOutput` and `DirectiveOutput`
2. **Add dispatch in global.rs** - Route to both handlers via enum match
3. **Never add mode parameters** - The handlers already know their mode

**Example: Adding a hypothetical `warning()` function**

This illustrates the pattern - follow these steps when adding any new output capability:

```rust
// In interactive.rs
impl InteractiveOutput {
    pub fn warning(&mut self, message: String) -> io::Result<()> {
        println!("{WARNING_EMOJI} {WARNING}{message}{WARNING:#}");
        Ok(())
    }
}

// In directive.rs
impl DirectiveOutput {
    pub fn warning(&mut self, message: String) -> io::Result<()> {
        // Warnings go to stderr in directive mode
        write!(io::stderr(), "{}\0", strip_str(&message))?;
        io::stderr().flush()
    }
}

// In global.rs
pub fn warning(message: impl Into<String>) -> io::Result<()> {
    OUTPUT_CONTEXT.with(|ctx| {
        let msg = message.into();
        match &mut *ctx.borrow_mut() {
            OutputHandler::Interactive(i) => i.warning(msg),
            OutputHandler::Directive(d) => d.warning(msg),
        }
    })
}
```

### Why This Matters

This architecture maintains the "one canonical path" principle from the global guidelines:

**Without this architecture**, you'd see:
- Mode conditionals scattered throughout 50+ command functions
- HIGH CARDINALITY: Two divergent code paths that must be kept in sync
- Mode parameters threading through the entire call stack
- Easy to forget one branch when changing behavior

**With this architecture**:
- Commands have ONE code path that works for both modes (LOW CARDINALITY)
- Mode-specific behavior encapsulated in two handler files
- Adding new commands requires zero mode awareness
- Changing behavior means updating one function, not hunting down 50+ conditionals

This is the same pattern as logging frameworks (`log`, `tracing`) - you configure once at startup, then the rest of the code just logs without caring where it goes.

### Red Flags and Solutions

**Red Flag: "I need to check if we're in interactive mode"**

This is always wrong. If you're tempted to check the mode, you have two options:

1. **The behavior should be the same in both modes** - Just do it directly, no check needed
2. **The behavior should differ between modes** - Add a new output function that encapsulates the difference

**Example scenario**: "I want to print a hint in interactive mode but not directive mode"

```rust
// ‚ùå DON'T DO THIS
if mode == OutputMode::Interactive {
    println!("üí° Use 'wt list' to see all worktrees");
}

// ‚úÖ DO THIS - progress() already handles this (shown in interactive, suppressed in directive)
output::progress("üí° Use 'wt list' to see all worktrees")?;
```

If the output function you need doesn't exist yet, follow the pattern in "Adding New Output Functions" above.

### Architectural Constraint: --internal Commands Must Use Output System

**CRITICAL: Commands that support `--internal` mode must NEVER use direct print macros (`print!()`, `println!()`, `eprint!()`, or `eprintln!()`).**

Commands that support the `--internal` flag (switch, remove, merge) emit directives for shell wrapper integration. Using direct print statements bypasses the output system and causes directive leaks - directives become visible to users in interactive mode.

#### The Problem

When a command uses `println!()` directly:

1. **Interactive mode**: Output appears correctly (luck, not design)
2. **Directive mode**: Direct prints get concatenated with NUL-terminated directives, causing directives to leak into user-visible output

**Example of the bug:**
```
üîÑ Starting (background):
__WORKTRUNK_CD__/Users/name/workspace/repo.branch
Created new worktree...
```

The `__WORKTRUNK_CD__` directive should be invisible, parsed only by the shell wrapper.

#### The Solution

**Commands supporting `--internal` must use `crate::output::*` functions exclusively:**

```rust
// ‚ùå NEVER DO THIS in commands that support --internal
println!("üîÑ Starting operation...");
print!("{}", formatted_output);
eprintln!("Some progress message");
eprint!("{}", error_message);

// ‚úÖ ALWAYS DO THIS
crate::output::progress("üîÑ Starting operation...")?;
crate::output::progress(formatted_output)?;
crate::output::progress("Some progress message")?;
crate::output::progress(error_message)?;
```

#### Which Commands Are Restricted

Files that support `--internal` mode (see `scripts/check-output-system.sh`):

- `src/commands/worktree.rs` (switch, remove commands)
- `src/commands/merge.rs` (merge command)

Other command files can use direct `println!()` if they never emit directives.

#### Enforcement

The restriction is enforced by:

1. **Lint script**: `scripts/check-output-system.sh` checks restricted files for direct print usage
2. **Integration tests**: `tests/integration_tests/shell_wrapper.rs` executes commands through the actual bash wrapper to catch directive leaks

Run the lint script to verify compliance:
```bash
./scripts/check-output-system.sh
```

#### Why This Matters

This constraint maintains architectural integrity:

- **Separation of concerns**: Output formatting is centralized in the output system
- **Mode transparency**: Commands don't need to know which mode they're running in
- **Protocol correctness**: Directives are properly NUL-terminated and never leak
- **Testability**: Shell integration can be tested end-to-end

When adding new functionality to restricted commands, always ask: "Does this need output?" If yes, use `crate::output::progress()` or `crate::output::success()`, never direct prints.

## Testing Guidelines

### Testing with --execute Commands

When testing commands that require confirmation (e.g., `wt switch --execute "..."`), use the `--force` flag to skip the interactive prompt:

```bash
# Good - skips confirmation prompt for testing
wt switch --create feature --execute "echo test" --force

# Bad - DO NOT pipe 'yes' to stdin, this crashes Claude
echo yes | wt switch --create feature --execute "echo test"
```

**Why `--force`?**
- Non-interactive testing requires automated approval
- Piping input to stdin interferes with Claude's I/O handling
- `--force` provides explicit, testable behavior
