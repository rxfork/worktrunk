//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! To enable automatic cd, run: wt configure-shell
//!
//! $ pwd
//! /original/directory  # ‚Üê User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ‚Üê Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt init bash)"`), the shell function intercepts
//! commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary outputs special directive protocol:
//!    ```
//!    __WORKTRUNK_CD__/path/to/worktree
//!    Created new branch and worktree for 'my-feature' at /path/to/worktree
//!    ```
//! 3. Shell wrapper parses output line-by-line
//! 4. When it sees `__WORKTRUNK_CD__<path>`, it executes `cd <path>` in the parent shell
//! 5. Other lines are printed normally
//!
//! The binary **never changes directories itself** - it just communicates the desired path back
//! to the shell wrapper via stdout using the `__WORKTRUNK_CD__` directive protocol.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) provide two formatting methods:
//!
//! - `format_user_output()`: Returns human-friendly messages (no directives)
//! - `format_internal_output()`: Returns directive protocol + messages
//!
//! The shell wrapper is generated by `wt init <shell>` from templates in `templates/`.
//!
//! See also: DEMO.md for detailed architecture explanation.

use std::collections::HashMap;
use std::io::{self, Write};
use std::path::PathBuf;
use worktrunk::config::{ProjectConfig, WorktrunkConfig, expand_template};
use worktrunk::git::{GitError, Repository};
use worktrunk::shell::Shell;
use worktrunk::styling::{
    AnstyleStyle, ERROR, ERROR_EMOJI, HINT, HINT_EMOJI, WARNING, WARNING_EMOJI, eprintln, println,
};

/// Generate hint message for shell integration setup
///
/// Returns a hint message based on whether shell integration is configured:
/// - If configured but not active: provides exact source command
/// - If not configured: suggests running configure-shell
fn shell_integration_hint() -> String {
    if let Some(config_path) = Shell::is_integration_configured() {
        format!(
            "\n\nShell integration configured. Restart your shell or run: source {}",
            config_path.display()
        )
    } else {
        "\n\nTo enable automatic cd, run: wt configure-shell".to_string()
    }
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Switched to existing worktree at the given path
    ExistingWorktree(PathBuf),
    /// Created new worktree at the given path
    CreatedWorktree { path: PathBuf, created_branch: bool },
}

impl SwitchResult {
    /// Format the result for display (non-internal mode)
    pub fn format_user_output(&self, branch: &str) -> Option<String> {
        use anstyle::{AnsiColor, Color};

        match self {
            SwitchResult::ExistingWorktree(_path) => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();
                Some(format!(
                    "‚úÖ {green}Switched to worktree for {green_bold}{branch}{green_bold:#}{green:#}\n\n{}",
                    shell_integration_hint()
                ))
            }
            SwitchResult::CreatedWorktree {
                path,
                created_branch,
            } => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();
                let dim = AnstyleStyle::new().dimmed();

                let msg = if *created_branch {
                    format!(
                        "‚úÖ {green}Created new worktree for {green_bold}{branch}{green_bold:#}{green:#}\n  {dim}Path: {}{dim:#}",
                        path.display()
                    )
                } else {
                    format!(
                        "‚úÖ {green}Added worktree for {green_bold}{branch}{green_bold:#}{green:#}\n  {dim}Path: {}{dim:#}",
                        path.display()
                    )
                };

                Some(format!("{}{}", msg, shell_integration_hint()))
            }
        }
    }

    /// Format the result for shell integration (internal mode)
    pub fn format_internal_output(&self, branch: &str) -> Option<String> {
        use anstyle::{AnsiColor, Color};

        match self {
            SwitchResult::ExistingWorktree(path) => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();
                Some(format!(
                    "__WORKTRUNK_CD__{}\n‚úÖ {green}Switched to worktree for {green_bold}{branch}{green_bold:#}{green:#}",
                    path.display()
                ))
            }
            SwitchResult::CreatedWorktree {
                path,
                created_branch,
            } => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();

                let msg = if *created_branch {
                    format!(
                        "‚úÖ {green}Created new worktree for {green_bold}{branch}{green_bold:#}{green:#}"
                    )
                } else {
                    format!(
                        "‚úÖ {green}Added worktree for {green_bold}{branch}{green_bold:#}{green:#}"
                    )
                };
                Some(format!("__WORKTRUNK_CD__{}\n{}", path.display(), msg))
            }
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Already on default branch, no action taken
    AlreadyOnDefault(String),
    /// Removed worktree and returned to primary
    RemovedWorktree { primary_path: PathBuf },
    /// Switched to default branch in main repo
    SwitchedToDefault(String),
}

impl RemoveResult {
    /// Format the result for display (non-internal mode)
    pub fn format_user_output(&self) -> Option<String> {
        use anstyle::{AnsiColor, Color};

        match self {
            RemoveResult::AlreadyOnDefault(branch) => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();
                Some(format!(
                    "‚úÖ {green}Already on default branch {green_bold}{branch}{green_bold:#}{green:#}"
                ))
            }
            RemoveResult::RemovedWorktree { primary_path } => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let dim = AnstyleStyle::new().dimmed();
                Some(format!(
                    "‚úÖ {green}Removed worktree and returned to primary{green:#}\n  {dim}Path: {}{dim:#}\n\nTo enable automatic cd, run: wt configure-shell",
                    primary_path.display()
                ))
            }
            RemoveResult::SwitchedToDefault(branch) => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                let green_bold = green.bold();
                Some(format!(
                    "‚úÖ {green}Switched to default branch {green_bold}{branch}{green_bold:#}{green:#}"
                ))
            }
        }
    }

    /// Format the result for shell integration (internal mode)
    pub fn format_internal_output(&self) -> Option<String> {
        use anstyle::{AnsiColor, Color};

        match self {
            RemoveResult::AlreadyOnDefault(_) => None,
            RemoveResult::RemovedWorktree { primary_path } => {
                let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
                Some(format!(
                    "__WORKTRUNK_CD__{}\n‚úÖ {green}Removed worktree and returned to primary{green:#}",
                    primary_path.display()
                ))
            }
            RemoveResult::SwitchedToDefault(_) => None,
        }
    }
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    execute: Option<&str>,
    force: bool,
    config: &WorktrunkConfig,
) -> Result<SwitchResult, GitError> {
    let repo = Repository::current();

    // Check for conflicting conditions
    if create && repo.branch_exists(branch)? {
        let error_bold = ERROR.bold();
        eprintln!(
            "{ERROR_EMOJI} {ERROR}Branch {error_bold}{branch}{error_bold:#} already exists{ERROR:#}"
        );
        eprintln!();
        eprintln!("{HINT_EMOJI} {HINT}Remove --create flag to switch to it{HINT:#}");
        return Err(GitError::CommandFailed(String::new()));
    }

    // Check if base flag was provided without create flag
    if base.is_some() && !create {
        eprintln!(
            "{WARNING_EMOJI} {WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        );
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(branch)? {
        Some(existing_path) if existing_path.exists() => {
            if let Some(cmd) = execute {
                execute_command_in_worktree(&existing_path, cmd)?;
            }
            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);
            return Ok(SwitchResult::ExistingWorktree(canonical_existing_path));
        }
        Some(_) => {
            let error_bold = ERROR.bold();
            eprintln!(
                "{ERROR_EMOJI} {ERROR}Worktree directory missing for {error_bold}{branch}{error_bold:#}{ERROR:#}"
            );
            eprintln!();
            eprintln!("{HINT_EMOJI} {HINT}Run 'git worktree prune' to clean up{HINT:#}");
            return Err(GitError::CommandFailed(String::new()));
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.repo_root()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::CommandFailed("Invalid repository path".to_string()))?
        .to_str()
        .ok_or_else(|| GitError::CommandFailed("Invalid UTF-8 in path".to_string()))?;

    let worktree_path = repo_root.join(config.format_path(repo_name, branch));

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];
    if create {
        args.push("-b");
        args.push(branch);
        if let Some(base_branch) = base {
            args.push(base_branch);
        }
    } else {
        args.push(branch);
    }

    repo.run_command(&args)
        .map_err(|e| GitError::CommandFailed(format!("Failed to create worktree: {}", e)))?;

    // Canonicalize the path for cleaner display
    let canonical_path = worktree_path
        .canonicalize()
        .unwrap_or_else(|_| worktree_path.clone());

    // Execute post-start commands from project config (before -x command)
    execute_post_start_commands(&canonical_path, &repo, config, branch, repo_name, force)?;

    // Execute -x command last (after setup is complete)
    if let Some(cmd) = execute {
        execute_command_in_worktree(&worktree_path, cmd)?;
    }

    Ok(SwitchResult::CreatedWorktree {
        path: canonical_path,
        created_branch: create,
    })
}

/// Execute a command in the specified worktree directory
fn execute_command_in_worktree(
    worktree_path: &std::path::Path,
    command: &str,
) -> Result<(), GitError> {
    #[cfg(target_os = "windows")]
    let (shell, shell_arg) = ("cmd", "/C");
    #[cfg(not(target_os = "windows"))]
    let (shell, shell_arg) = ("sh", "-c");

    let status = std::process::Command::new(shell)
        .arg(shell_arg)
        .arg(command)
        .current_dir(worktree_path)
        .stdin(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .stderr(std::process::Stdio::inherit())
        .status()
        .map_err(|e| GitError::CommandFailed(format!("Failed to execute command: {}", e)))?;

    if !status.success() {
        return Err(GitError::CommandFailed(format!(
            "Command '{}' failed with exit code {}",
            command,
            status.code().unwrap_or(-1)
        )));
    }

    Ok(())
}

pub fn handle_remove() -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Check for uncommitted changes
    repo.ensure_clean_working_tree()?;

    // Get current state
    let current_branch = repo.current_branch()?;
    let default_branch = repo.default_branch()?;
    let in_worktree = repo.is_in_worktree()?;

    // If we're on default branch and not in a worktree, nothing to do
    if !in_worktree && current_branch.as_deref() == Some(&default_branch) {
        return Ok(RemoveResult::AlreadyOnDefault(default_branch));
    }

    if in_worktree {
        // In worktree: navigate to primary worktree and remove this one
        let worktree_root = repo.worktree_root()?;
        let primary_worktree_dir = repo.repo_root()?;

        // Remove the worktree
        if let Err(e) = repo.remove_worktree(&worktree_root) {
            eprintln!("{WARNING_EMOJI} {WARNING}Failed to remove worktree: {e}{WARNING:#}");
            eprintln!(
                "You may need to run 'git worktree remove {}' manually",
                worktree_root.display()
            );
        }

        // Canonicalize the path for cleaner display
        let canonical_primary_path = primary_worktree_dir
            .canonicalize()
            .unwrap_or(primary_worktree_dir);

        Ok(RemoveResult::RemovedWorktree {
            primary_path: canonical_primary_path,
        })
    } else {
        // In main repo but not on default branch: switch to default
        repo.run_command(&["switch", &default_branch])
            .map_err(|e| {
                GitError::CommandFailed(format!("Failed to switch to '{}': {}", default_branch, e))
            })?;

        Ok(RemoveResult::SwitchedToDefault(default_branch))
    }
}

/// Check for conflicting uncommitted changes in target worktree
fn check_worktree_conflicts(
    repo: &Repository,
    target_worktree: &Option<std::path::PathBuf>,
    target_branch: &str,
) -> Result<(), GitError> {
    let Some(wt_path) = target_worktree else {
        return Ok(());
    };

    let wt_repo = Repository::at(wt_path);
    if !wt_repo.is_dirty()? {
        return Ok(());
    }

    // Get files changed in the push
    let push_files = repo.changed_files(target_branch, "HEAD")?;

    // Get files changed in the worktree
    let wt_status_output = wt_repo.run_command(&["status", "--porcelain"])?;

    let wt_files: Vec<String> = wt_status_output
        .lines()
        .filter_map(|line| {
            // Parse porcelain format: "XY filename"
            line.split_once(' ')
                .map(|(_, filename)| filename.trim().to_string())
        })
        .collect();

    // Find overlapping files
    let overlapping: Vec<String> = push_files
        .iter()
        .filter(|f| wt_files.contains(f))
        .cloned()
        .collect();

    if !overlapping.is_empty() {
        eprintln!("{ERROR_EMOJI} {ERROR}Cannot push: conflicting uncommitted changes in:{ERROR:#}");
        eprintln!();
        let dim = AnstyleStyle::new().dimmed();
        for file in &overlapping {
            eprintln!("  {dim}‚Ä¢{dim:#} {}", file);
        }
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}Commit or stash these changes in {} first{HINT:#}",
            wt_path.display()
        );
        return Err(GitError::CommandFailed(String::new()));
    }

    Ok(())
}

/// Replace template variables in a command string
///
/// Supported variables:
/// - `{repo}` - Repository name
/// - `{branch}` - Branch name (sanitized)
/// - `{worktree}` - Path to the new worktree
/// - `{repo_root}` - Path to the main repository root
fn expand_command_template(
    command: &str,
    repo_name: &str,
    branch: &str,
    worktree_path: &std::path::Path,
    repo_root: &std::path::Path,
) -> String {
    let mut extra = HashMap::new();
    extra.insert("worktree", worktree_path.to_str().unwrap_or(""));
    extra.insert("repo_root", repo_root.to_str().unwrap_or(""));

    expand_template(command, repo_name, branch, &extra)
}

/// Prompt the user to approve a command for execution
fn prompt_for_approval(command: &str, project_id: &str) -> io::Result<bool> {
    use anstyle::Style;
    use worktrunk::styling::{HINT_EMOJI, eprint};

    // Extract project name from project_id (e.g., "worktrunk" from "github.com/max-sixty/worktrunk")
    let project_name = project_id.split('/').next_back().unwrap_or(project_id);
    let bold = Style::new().bold();
    let dim = Style::new().dimmed();

    eprintln!();
    eprintln!("{WARNING_EMOJI} {WARNING}Permission required to execute in worktree{WARNING:#}");
    eprintln!();
    eprintln!("{bold}{project_name}{bold:#} ({project_id}) wants to execute:");
    eprintln!();
    eprintln!("    {dim}{command}{dim:#}");
    eprintln!();
    eprint!("{HINT_EMOJI} Allow and remember? {bold}[y/N]{bold:#} ");
    io::stderr().flush()?;

    let mut input = String::new();
    io::stdin().read_line(&mut input)?;

    let response = input.trim().to_lowercase();
    Ok(response == "y" || response == "yes")
}

/// Execute post-start commands from project config
fn execute_post_start_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    repo_name: &str,
    force: bool,
) -> Result<(), GitError> {
    // Load project config
    let repo_root = repo.repo_root()?;
    let config_path = repo_root.join(".config").join("wt.toml");
    let project_config = match ProjectConfig::load(&repo_root) {
        Ok(Some(cfg)) => cfg,
        Ok(None) => return Ok(()), // No project config
        Err(e) => {
            eprintln!(
                "{WARNING_EMOJI} {WARNING}Failed to load project config from {}{WARNING:#}",
                config_path.display()
            );
            eprintln!("{HINT_EMOJI} {HINT}Error details: {e}{HINT:#}");
            eprintln!(
                "{HINT_EMOJI} {HINT}Skipping post-start commands. Check TOML syntax if file exists.{HINT:#}"
            );
            return Ok(());
        }
    };

    if project_config.post_start_commands.is_empty() {
        return Ok(());
    }

    // Get project identifier
    let project_id = repo.project_identifier()?;

    // Execute each command
    for command in &project_config.post_start_commands {
        // Check if command is already approved or if force flag is set
        let approved = if force || config.is_command_approved(&project_id, command) {
            true
        } else {
            // Prompt for approval
            match prompt_for_approval(command, &project_id) {
                Ok(true) => {
                    // Reload config and save approval
                    match WorktrunkConfig::load() {
                        Ok(mut fresh_config) => {
                            if let Err(e) =
                                fresh_config.approve_command(project_id.clone(), command.clone())
                            {
                                eprintln!(
                                    "{WARNING_EMOJI} {WARNING}Failed to save command approval: {e}{WARNING:#}"
                                );
                                eprintln!("You will be prompted again next time.");
                            }
                        }
                        Err(e) => {
                            eprintln!(
                                "{WARNING_EMOJI} {WARNING}Failed to reload config for saving approval: {e}{WARNING:#}"
                            );
                            eprintln!("You will be prompted again next time.");
                        }
                    }
                    true
                }
                Ok(false) => {
                    let dim = AnstyleStyle::new().dimmed();
                    eprintln!("{dim}Skipping command: {command}{dim:#}");
                    false
                }
                Err(e) => {
                    eprintln!("{WARNING_EMOJI} {WARNING}Failed to read user input: {e}{WARNING:#}");
                    false
                }
            }
        };

        if approved {
            // Expand template variables in the command
            let expanded_command =
                expand_command_template(command, repo_name, branch, worktree_path, &repo_root);

            use anstyle::{AnsiColor, Color};
            use std::io::Write;
            let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
            eprintln!("üîÑ {cyan}Executing: {expanded_command}{cyan:#}");
            // Flush stderr to ensure message is displayed before command execution
            let _ = std::io::stderr().flush();
            if let Err(e) = execute_command_in_worktree(worktree_path, &expanded_command) {
                eprintln!("{WARNING_EMOJI} {WARNING}Command failed: {e}{WARNING:#}");
                // Continue with other commands even if one fails
            }
        }
    }

    // Flush all output before returning to ensure proper display order
    use std::io::Write;
    let _ = std::io::stdout().flush();
    let _ = std::io::stderr().flush();

    Ok(())
}

pub fn handle_push(target: Option<&str>, allow_merge_commits: bool) -> Result<(), GitError> {
    use anstyle::{AnsiColor, Color};

    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = target.map_or_else(|| repo.default_branch(), |b| Ok(b.to_string()))?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        let error_bold = ERROR.bold();
        eprintln!(
            "{ERROR_EMOJI} {ERROR}Not a fast-forward from {error_bold}{target_branch}{error_bold:#} to HEAD{ERROR:#}"
        );
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}The target branch has commits not in your current branch{HINT:#}"
        );
        eprintln!("{HINT_EMOJI} {HINT}Consider: git pull or git rebase{HINT:#}");
        return Err(GitError::CommandFailed(String::new()));
    }

    // Check for merge commits unless allowed
    if !allow_merge_commits && repo.has_merge_commits(&target_branch, "HEAD")? {
        eprintln!("{ERROR_EMOJI} {ERROR}Found merge commits in push range{ERROR:#}");
        eprintln!();
        eprintln!(
            "{HINT_EMOJI} {HINT}Use --allow-merge-commits to push non-linear history{HINT:#}"
        );
        return Err(GitError::CommandFailed(String::new()));
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    check_worktree_conflicts(&repo, &target_worktree, &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics early so we can use them in the summary
    let diff_shortstat = if commit_count > 0 {
        repo.run_command(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])?
    } else {
        String::new()
    };

    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
        let cyan_bold = cyan.bold();

        println!(
            "üîÑ {cyan}Pushing {commit_count} {commit_text} to {cyan_bold}{target_branch}{cyan_bold:#} @ {head_sha}{cyan:#}"
        );
        println!();

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        println!("{}", log_output.trim());
        println!();

        // Show diff statistics with color
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            println!("{}", diff_stat);
            println!();
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target])
        .map_err(|e| {
            GitError::CommandFailed(format!("{ERROR_EMOJI} {ERROR}Push failed: {e}{ERROR:#}"))
        })?;

    // Build success message with statistics
    let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
    let green_bold = green.bold();

    if commit_count > 0 {
        // Parse shortstat to extract files/insertions/deletions
        // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
        let stats = parse_diff_shortstat(&diff_shortstat);

        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];

        if let Some(files) = stats.files {
            summary_parts.push(format!(
                "{} file{}",
                files,
                if files == 1 { "" } else { "s" }
            ));
        }
        if let Some(insertions) = stats.insertions {
            let addition = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
            summary_parts.push(format!("{addition}+{insertions}{addition:#}"));
        }
        if let Some(deletions) = stats.deletions {
            let deletion = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Red)));
            summary_parts.push(format!("{deletion}-{deletions}{deletion:#}"));
        }

        println!(
            "‚úÖ {green}Pushed to {green_bold}{target_branch}{green_bold:#} ({})  {green:#}",
            summary_parts.join(", ")
        );
    } else {
        println!("‚úÖ {green}Pushed to {green_bold}{target_branch}{green_bold:#}{green:#}");
    }

    Ok(())
}

/// Parse git diff --shortstat output
struct DiffStats {
    files: Option<usize>,
    insertions: Option<usize>,
    deletions: Option<usize>,
}

fn parse_diff_shortstat(output: &str) -> DiffStats {
    let mut stats = DiffStats {
        files: None,
        insertions: None,
        deletions: None,
    };

    // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
    let parts: Vec<&str> = output.split(',').collect();

    for part in parts {
        let part = part.trim();

        if part.contains("file") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.files = num_str.parse().ok();
            }
        } else if part.contains("insertion") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.insertions = num_str.parse().ok();
            }
        } else if part.contains("deletion")
            && let Some(num_str) = part.split_whitespace().next()
        {
            stats.deletions = num_str.parse().ok();
        }
    }

    stats
}
