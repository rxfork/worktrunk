//! Worktree operations with file-based shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: File-Based Directive Passing
//!
//! Shell wrappers create a temp file and set `WORKTRUNK_DIRECTIVE_FILE` to its path:
//!
//! 1. Shell wrapper creates temp file via `mktemp`
//! 2. Shell wrapper sets `WORKTRUNK_DIRECTIVE_FILE=/path/to/temp`
//! 3. wt binary writes commands like `cd '/path'` to that file
//! 4. Shell wrapper sources the file after wt exits
//!
//! ## Without Shell Integration (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! Run `wt config shell install` to enable automatic cd
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With Shell Integration
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt config shell init bash)"`), the shell wrapper:
//!
//! 1. Creates a temp file and sets `WORKTRUNK_DIRECTIVE_FILE` to its path
//! 2. Runs the wt binary (which writes `cd '/path'` to the temp file)
//! 3. Sources the temp file after wt exits
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! The output handlers check `is_shell_integration_active()` to determine if hints should
//! be suppressed (when shell integration is already configured).
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **If wt operation fails**: Returns wt's exit code (command never executes)
//! - **If wt succeeds but command fails**: Returns the command's exit code
//! - **Rationale**: Enables command chaining with proper error propagation
//!
//! Example:
//! ```bash
//! wt switch feature -x "cargo build" && cargo test
//! # If wt fails (e.g., worktree doesn't exist), cargo build never runs
//! # If cargo build fails, cargo test doesn't run (exit code propagates)
//! ```
//!
//! The shell wrapper is generated by `wt config shell init <shell>` from templates in `templates/`.

use anyhow::Context;
use color_print::cformat;
use dunce::canonicalize;
use normalize_path::NormalizePath;
use std::path::{Path, PathBuf};
use worktrunk::HookType;
use worktrunk::config::WorktrunkConfig;
use worktrunk::git::{GitError, Repository, ResolvedWorktree};
use worktrunk::styling::{
    format_with_gutter, hint_message, info_message, progress_message, success_message,
    suggest_command, warning_message,
};

use super::command_executor::CommandContext;
use super::hooks::{HookFailureStrategy, prepare_hook_commands, spawn_hook_commands_background};
use super::repository_ext::{RemoveTarget, RepositoryCliExt};

/// Generate a backup path for the given path with a timestamp suffix.
///
/// For paths with extensions: `file.txt` → `file.txt.bak.TIMESTAMP`
/// For paths without extensions: `foo` → `foo.bak.TIMESTAMP`
///
/// Returns an error for unusual paths without a file name (e.g., `/` or `..`).
fn generate_backup_path(path: &std::path::Path, suffix: &str) -> anyhow::Result<PathBuf> {
    let file_name = path
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("Cannot generate backup path for {}", path.display()))?;

    if path.extension().is_none() {
        // Path has no extension (e.g., /repo/feature)
        Ok(path.with_file_name(format!("{}.bak.{suffix}", file_name.to_string_lossy())))
    } else {
        // Path has an extension (e.g., /repo.feature or /file.txt)
        Ok(path.with_extension(format!(
            "{}.bak.{suffix}",
            path.extension()
                .map(|e| e.to_string_lossy().to_string())
                .unwrap_or_default()
        )))
    }
}

/// Context for worktree resolution - determines which checks are performed.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResolutionContext {
    /// Creating or switching to a worktree - path occupation is an error
    /// because we need to create a worktree at the expected path.
    CreateOrSwitch,
    /// Removing a worktree - we only care if the branch has a worktree,
    /// path occupation is irrelevant since we're not creating anything.
    Remove,
}

/// Resolve a worktree argument using branch-first lookup.
///
/// Resolution order:
/// 1. Special symbols ("@", "-", "^") are handled specially
/// 2. Resolve argument as branch name
/// 3. If branch has a worktree, return it
/// 4. Otherwise, return branch-only (no worktree)
///
/// For `CreateOrSwitch` context: If the branch has no worktree but expected
/// path is occupied by another branch's worktree, an error is raised.
///
/// For `Remove` context: Path occupation is ignored since we're not creating
/// a worktree - we just return `BranchOnly` if no worktree exists.
pub fn resolve_worktree_arg(
    repo: &Repository,
    name: &str,
    config: &WorktrunkConfig,
    context: ResolutionContext,
) -> anyhow::Result<ResolvedWorktree> {
    // Special symbols - delegate to Repository for consistent error handling
    match name {
        "@" | "-" | "^" => {
            return repo.resolve_worktree(name);
        }
        _ => {}
    }

    // Resolve as branch name
    let branch = repo.resolve_worktree_name(name)?;

    // Branch-first: check if branch has worktree anywhere
    if let Some(path) = repo.worktree_for_branch(&branch)? {
        return Ok(ResolvedWorktree::Worktree {
            path,
            branch: Some(branch),
        });
    }

    // No worktree for branch - check if expected path is occupied (only for create/switch)
    if context == ResolutionContext::CreateOrSwitch {
        let expected_path = compute_worktree_path(repo, name, config)?;
        if let Some((_, occupant_branch)) = repo.worktree_at_path(&expected_path)? {
            // Path is occupied by a different branch's worktree
            return Err(GitError::WorktreePathOccupied {
                branch,
                path: expected_path,
                occupant: occupant_branch,
            }
            .into());
        }
    }

    // No worktree for branch (and path not occupied, or we don't care about path)
    Ok(ResolvedWorktree::BranchOnly { branch })
}

/// Compute the expected worktree path for a branch name.
///
/// For the default branch, returns the repo root (main worktree location).
/// For other branches, applies the `worktree-path` template from config.
///
/// Uses cached values from Repository for `default_branch` and `is_bare`.
pub fn compute_worktree_path(
    repo: &Repository,
    branch: &str,
    config: &WorktrunkConfig,
) -> anyhow::Result<PathBuf> {
    let repo_root = repo.repo_path()?;
    let default_branch = repo.default_branch().unwrap_or_default();
    let is_bare = repo.is_bare()?;

    // Default branch lives at repo root (main worktree), not a templated path.
    // Exception: bare repos have no main worktree, so all branches use templated paths.
    if !is_bare && branch == default_branch {
        return Ok(repo_root);
    }

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("Repository path has no filename: {}", repo_root.display()))?
        .to_str()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Repository path contains invalid UTF-8: {}",
                repo_root.display()
            )
        })?;

    let relative_path = config
        .format_path(repo_name, branch, repo)
        .map_err(|e| anyhow::anyhow!("Failed to format worktree path: {e}"))?;

    Ok(repo_root.join(relative_path).normalize())
}

/// Check if a worktree is at its expected path based on config template.
///
/// Returns true if the worktree's actual path matches what `compute_worktree_path`
/// would generate for its branch. Detached HEAD always returns false (no expected path).
///
/// Uses canonicalization to handle symlinks and relative paths correctly.
/// Uses cached values from Repository for `default_branch` and `is_bare`.
pub fn is_worktree_at_expected_path(
    wt: &worktrunk::git::WorktreeInfo,
    repo: &Repository,
    config: &WorktrunkConfig,
) -> bool {
    match &wt.branch {
        Some(branch) => compute_worktree_path(repo, branch, config)
            .map(|expected| paths_match(&wt.path, &expected))
            .unwrap_or(false),
        None => false,
    }
}

/// Compare two paths for equality, canonicalizing to handle symlinks and relative paths.
///
/// Returns `true` if the paths resolve to the same location.
fn paths_match(a: &std::path::Path, b: &std::path::Path) -> bool {
    use dunce::canonicalize;
    let a_canonical = canonicalize(a).unwrap_or_else(|_| a.to_path_buf());
    let b_canonical = canonicalize(b).unwrap_or_else(|_| b.to_path_buf());
    a_canonical == b_canonical
}

/// Returns the expected path if `actual_path` differs from the template-computed path.
///
/// Returns `Some(expected_path)` when there's a mismatch, `None` when paths match.
/// Used to show path mismatch warnings in `wt remove` and `wt merge`.
pub fn get_path_mismatch(
    repo: &Repository,
    branch: &str,
    actual_path: &std::path::Path,
    config: &WorktrunkConfig,
) -> Option<PathBuf> {
    compute_worktree_path(repo, branch, config)
        .ok()
        .filter(|expected| !paths_match(actual_path, expected))
}

/// Compute a user-facing display name for a worktree.
///
/// Returns styled content with branch names bolded:
/// - If branch is consistent with worktree location: just the branch name (bolded)
/// - If branch differs from expected location: `dir_name (on **branch**)` (both bolded)
/// - If detached HEAD: `dir_name (detached)` (dir_name bolded)
///
/// "Consistent" means the worktree path matches `compute_worktree_path(branch)`,
/// which returns repo root for default branch and templated path for others.
pub fn worktree_display_name(
    wt: &worktrunk::git::WorktreeInfo,
    repo: &Repository,
    config: &WorktrunkConfig,
) -> String {
    let dir_name = wt.dir_name();

    match &wt.branch {
        Some(branch) => {
            if is_worktree_at_expected_path(wt, repo, config) {
                cformat!("<bold>{branch}</>")
            } else {
                cformat!("<bold>{dir_name}</> (on <bold>{branch}</>)")
            }
        }
        None => cformat!("<bold>{dir_name}</> (detached)"),
    }
}

/// Flags indicating which merge operations occurred
#[derive(Debug, Clone, Copy)]
pub struct MergeOperations {
    pub committed: bool,
    pub squashed: bool,
    pub rebased: bool,
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Already at the target worktree (no action taken)
    AlreadyAt(PathBuf),
    /// Switched to existing worktree at the given path
    Existing(PathBuf),
    /// Created new worktree at the given path
    Created {
        path: PathBuf,
        /// True if we used `-b` to create a new branch (--create flag)
        created_branch: bool,
        /// Base branch when creating new branch (e.g., "main")
        base_branch: Option<String>,
        /// Absolute path to base branch's worktree (POSIX format for shell compatibility)
        base_worktree_path: Option<String>,
        /// Remote tracking branch if created from remote (e.g., "origin/feature")
        /// This is set when git's DWIM created a local branch from a remote
        from_remote: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::AlreadyAt(path) => path,
            SwitchResult::Existing(path) => path,
            SwitchResult::Created { path, .. } => path,
        }
    }
}

/// Branch state for a switch operation.
#[derive(Debug, Clone)]
pub struct SwitchBranchInfo {
    /// The branch being switched to
    pub branch: String,
    /// Expected path when there's a branch-worktree mismatch (None = path matches template)
    pub expected_path: Option<PathBuf>,
}

/// Validated plan for a switch operation.
///
/// Created by `plan_switch()`, consumed by `execute_switch()`.
/// This separation allows validation to happen before approval prompts,
/// ensuring users aren't asked to approve hooks for operations that will fail.
#[derive(Debug)]
pub enum SwitchPlan {
    /// Branch already has a worktree - just switch to it (no git commands needed)
    Existing {
        path: PathBuf,
        branch: String,
        /// Expected path for mismatch detection
        expected_path: PathBuf,
        /// Branch to record as "previous" for `wt switch -`
        new_previous: Option<String>,
    },
    /// Need to create a new worktree
    Create {
        branch: String,
        worktree_path: PathBuf,
        /// True if using `-b` to create a new branch (--create flag)
        create_branch: bool,
        /// Base branch for creation (resolved, validated to exist)
        base_branch: Option<String>,
        /// If path exists and --clobber, this is the backup path to move it to
        clobber_backup: Option<PathBuf>,
        /// Branch to record as "previous" for `wt switch -`
        new_previous: Option<String>,
    },
}

impl SwitchPlan {
    /// Get the worktree path for this plan.
    pub fn worktree_path(&self) -> &Path {
        match self {
            SwitchPlan::Existing { path, .. } => path,
            SwitchPlan::Create { worktree_path, .. } => worktree_path,
        }
    }

    /// Get the branch name for this plan.
    pub fn branch(&self) -> &str {
        match self {
            SwitchPlan::Existing { branch, .. } => branch,
            SwitchPlan::Create { branch, .. } => branch,
        }
    }

    /// Returns true if this plan will create a new worktree.
    pub fn is_create(&self) -> bool {
        matches!(self, SwitchPlan::Create { .. })
    }
}

/// How the branch should be handled after worktree removal.
///
/// This enum replaces the previous `no_delete_branch: bool, force_delete: bool` pattern,
/// making the three valid states explicit and preventing invalid combinations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BranchDeletionMode {
    /// Keep the branch regardless of merge status (--no-delete-branch flag).
    Keep,
    /// Delete the branch only if it's fully merged into the target branch (default).
    SafeDelete,
    /// Delete the branch even if it's not merged (-D flag).
    ForceDelete,
}

impl BranchDeletionMode {
    /// Create from CLI flags.
    ///
    /// `--no-delete-branch` takes precedence over `-D` (force delete).
    pub fn from_flags(no_delete_branch: bool, force_delete: bool) -> Self {
        if no_delete_branch {
            Self::Keep
        } else if force_delete {
            Self::ForceDelete
        } else {
            Self::SafeDelete
        }
    }

    /// Whether the branch should be kept (not deleted).
    pub fn should_keep(&self) -> bool {
        matches!(self, Self::Keep)
    }

    /// Whether to force delete even if not merged.
    pub fn is_force(&self) -> bool {
        matches!(self, Self::ForceDelete)
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Removed worktree and returned to main (if needed)
    RemovedWorktree {
        main_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        /// Branch name, if known. None for detached HEAD state.
        branch_name: Option<String>,
        deletion_mode: BranchDeletionMode,
        target_branch: Option<String>,
        /// Pre-computed integration reason (if branch is integrated with target).
        /// Computed upfront to avoid race conditions when removing multiple worktrees
        /// in background mode (background git operations can hold locks that cause
        /// subsequent integration checks to fail).
        integration_reason: Option<worktrunk::git::IntegrationReason>,
        /// Force git worktree removal even with untracked files.
        force_worktree: bool,
        /// Expected path based on config template. `Some` when actual path differs
        /// from expected (path mismatch), `None` when path matches template.
        expected_path: Option<PathBuf>,
    },
    /// Branch exists but has no worktree - attempt branch deletion only
    BranchOnly {
        branch_name: String,
        deletion_mode: BranchDeletionMode,
    },
}

/// Validate and plan a switch operation.
///
/// This performs all validation upfront, returning a `SwitchPlan` that can be
/// executed later. Call this BEFORE approval prompts to ensure users aren't
/// asked to approve hooks for operations that will fail.
///
/// Warnings (remote branch shadow, --base without --create, invalid default branch)
/// are printed during planning since they're informational, not blocking.
pub fn plan_switch(
    repo: &Repository,
    branch: &str,
    create: bool,
    base: Option<&str>,
    clobber: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<SwitchPlan> {
    // Get the actual current branch BEFORE switching.
    // This is what we'll record as "previous" in history for `wt switch -` support.
    let new_previous = repo.current_worktree().branch().ok().flatten();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo
        .resolve_worktree_name(branch)
        .context("Failed to resolve branch name")?;

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        }
        .into());
    }

    // Warn if --create would shadow a remote branch
    if create {
        let remotes = repo.remotes_with_branch(&resolved_branch)?;
        if !remotes.is_empty() {
            let remote_ref = format!("{}/{}", remotes[0], resolved_branch);
            crate::output::print(warning_message(cformat!(
                "Branch <bold>{resolved_branch}</> exists on remote ({remote_ref}); creating new branch from base instead"
            )))?;
            let remove_cmd = suggest_command("remove", &[&resolved_branch], &[]);
            let switch_cmd = suggest_command("switch", &[&resolved_branch], &[]);
            crate::output::print(hint_message(cformat!(
                "To switch to the remote branch, delete this branch and run without <bright-black>--create</>: <bright-black>{remove_cmd} && {switch_cmd}</>"
            )))?;
        }
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::print(warning_message(
            "--base flag is only used with --create, ignoring",
        ))?;
    }

    // Compute expected worktree path for this branch
    let expected_path = compute_worktree_path(repo, &resolved_branch, config)?;

    // Branch-first lookup: check if branch has a worktree anywhere
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            return Ok(SwitchPlan::Existing {
                path: canonicalize(&existing_path).unwrap_or(existing_path),
                branch: resolved_branch,
                expected_path,
                new_previous,
            });
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            }
            .into());
        }
        None => {}
    }

    // No worktree for branch - validate branch exists before proceeding
    if !create && !repo.branch_exists(&resolved_branch)? {
        return Err(GitError::InvalidReference {
            reference: resolved_branch.clone(),
        }
        .into());
    }

    // Check if expected path is occupied by a different branch's worktree
    if let Some((existing_path, path_branch)) = repo.worktree_at_path(&expected_path)? {
        if !existing_path.exists() {
            let branch = path_branch.unwrap_or_else(|| resolved_branch.clone());
            return Err(GitError::WorktreeMissing { branch }.into());
        }
        return Err(GitError::WorktreePathOccupied {
            branch: resolved_branch.clone(),
            path: expected_path,
            occupant: path_branch,
        }
        .into());
    }

    // Determine clobber backup path if needed
    let clobber_backup = if expected_path.exists() {
        if clobber {
            let timestamp = worktrunk::utils::get_now() as i64;
            let datetime =
                chrono::DateTime::from_timestamp(timestamp, 0).unwrap_or_else(chrono::Utc::now);
            let suffix = datetime.format("%Y%m%d-%H%M%S").to_string();
            let backup_path = generate_backup_path(&expected_path, &suffix)?;

            if backup_path.exists() {
                anyhow::bail!(
                    "Backup path already exists: {}",
                    worktrunk::path::format_path_for_display(&backup_path)
                );
            }
            Some(backup_path)
        } else {
            return Err(GitError::WorktreePathExists {
                branch: resolved_branch.clone(),
                path: expected_path,
                create,
            }
            .into());
        }
    } else {
        None
    };

    // Check for invalid configured default branch when creating without explicit --base
    if create
        && resolved_base.is_none()
        && let Some(configured) = repo.invalid_default_branch_config()
    {
        crate::output::print(warning_message(cformat!(
            "Configured default branch <bold>{configured}</> does not exist locally"
        )))?;
        crate::output::print(hint_message(cformat!(
            "To reset, run <bright-black>wt config state default-branch clear</>"
        )))?;
    }

    // Resolve base ref for creation (accepts any commit-ish: branch, tag, SHA, HEAD)
    let base_branch = if create {
        match resolved_base {
            Some(ref b) => {
                if !repo.ref_exists(b)? {
                    return Err(GitError::InvalidReference {
                        reference: b.clone(),
                    }
                    .into());
                }
                Some(b.clone())
            }
            None => repo
                .resolve_target_branch(None)
                .ok()
                .filter(|b| repo.local_branch_exists(b).unwrap_or(false)),
        }
    } else {
        None
    };

    Ok(SwitchPlan::Create {
        branch: resolved_branch,
        worktree_path: expected_path,
        create_branch: create,
        base_branch,
        clobber_backup,
        new_previous,
    })
}

/// Execute a validated switch plan.
///
/// Takes a `SwitchPlan` from `plan_switch()` and executes it.
/// For `SwitchPlan::Existing`, just records history.
/// For `SwitchPlan::Create`, creates the worktree and runs hooks.
pub fn execute_switch(
    repo: &Repository,
    plan: SwitchPlan,
    config: &WorktrunkConfig,
    force: bool,
    no_verify: bool,
) -> anyhow::Result<(SwitchResult, SwitchBranchInfo)> {
    match plan {
        SwitchPlan::Existing {
            path,
            branch,
            expected_path,
            new_previous,
        } => {
            let _ = repo.record_switch_previous(new_previous.as_deref());

            let current_dir = std::env::current_dir()
                .ok()
                .and_then(|p| canonicalize(&p).ok());
            let already_at_worktree = current_dir
                .as_ref()
                .map(|cur| cur == &path)
                .unwrap_or(false);

            let mismatch_path = if !paths_match(&path, &expected_path) {
                Some(expected_path)
            } else {
                None
            };

            let result = if already_at_worktree {
                SwitchResult::AlreadyAt(path)
            } else {
                SwitchResult::Existing(path)
            };

            Ok((
                result,
                SwitchBranchInfo {
                    branch,
                    expected_path: mismatch_path,
                },
            ))
        }

        SwitchPlan::Create {
            branch,
            worktree_path,
            create_branch,
            base_branch,
            clobber_backup,
            new_previous,
        } => {
            // Handle --clobber backup if needed
            if let Some(backup_path) = clobber_backup {
                let path_display = worktrunk::path::format_path_for_display(&worktree_path);
                let backup_display = worktrunk::path::format_path_for_display(&backup_path);
                crate::output::print(warning_message(cformat!(
                    "Moving <bold>{path_display}</> to <bold>{backup_display}</> (--clobber)"
                )))?;

                std::fs::rename(&worktree_path, &backup_path).with_context(|| {
                    format!("Failed to move {path_display} to {backup_display}")
                })?;
            }

            // Build git worktree add command
            let worktree_path_str = worktree_path.to_string_lossy();
            let mut args = vec!["worktree", "add", worktree_path_str.as_ref()];

            if create_branch {
                args.push("-b");
                args.push(&branch);
                if let Some(ref base) = base_branch {
                    args.push(base);
                }
            } else {
                args.push(&branch);
            }

            // Create worktree
            if let Err(e) = repo.run_command(&args) {
                return Err(GitError::WorktreeCreationFailed {
                    branch: branch.clone(),
                    base_branch: base_branch.clone(),
                    error: e.to_string(),
                }
                .into());
            }

            // Check if git's DWIM created a tracking branch from a remote
            let from_remote = if !create_branch {
                repo.upstream_branch(&branch)?
            } else {
                None
            };

            // Compute base worktree path for hooks and result
            let base_worktree_path = base_branch
                .as_ref()
                .and_then(|b| repo.worktree_for_branch(b).ok().flatten())
                .map(|p| worktrunk::path::to_posix_path(&p.to_string_lossy()));

            // Execute post-create commands
            if !no_verify {
                let repo_root = repo.repo_path()?;
                let ctx = CommandContext::new(
                    repo,
                    config,
                    Some(&branch),
                    &worktree_path,
                    &repo_root,
                    force,
                );

                let extra_vars: Vec<(&str, &str)> = [
                    base_branch.as_ref().map(|b| ("base", b.as_str())),
                    base_worktree_path
                        .as_ref()
                        .map(|p| ("base_worktree_path", p.as_str())),
                ]
                .into_iter()
                .flatten()
                .collect();

                ctx.execute_post_create_commands(&extra_vars)?;
            }

            // Record successful switch in history
            let _ = repo.record_switch_previous(new_previous.as_deref());

            Ok((
                SwitchResult::Created {
                    path: worktree_path,
                    created_branch: create_branch,
                    base_branch,
                    base_worktree_path,
                    from_remote,
                },
                SwitchBranchInfo {
                    branch,
                    expected_path: None,
                },
            ))
        }
    }
}

pub fn handle_remove(
    worktree_name: &str,
    no_delete_branch: bool,
    force_delete: bool,
    force_worktree: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current()?;

    // Progress message is shown in handle_removed_worktree_output() after pre-remove hooks run
    repo.prepare_worktree_removal(
        RemoveTarget::Branch(worktree_name),
        BranchDeletionMode::from_flags(no_delete_branch, force_delete),
        force_worktree,
        config,
    )
}

/// Handle removing the current worktree (supports detached HEAD state).
///
/// This is the path-based removal that handles the "@" shorthand, including
/// when HEAD is detached.
pub fn handle_remove_current(
    no_delete_branch: bool,
    force_delete: bool,
    force_worktree: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current()?;

    // Progress message is shown in handle_removed_worktree_output() after pre-remove hooks run
    repo.prepare_worktree_removal(
        RemoveTarget::Current,
        BranchDeletionMode::from_flags(no_delete_branch, force_delete),
        force_worktree,
        config,
    )
}

impl<'a> CommandContext<'a> {
    /// Execute post-create commands sequentially (blocking)
    ///
    /// Runs user hooks first, then project hooks.
    /// Shows path in hook announcements when shell integration isn't active (user's shell
    /// won't cd to the new worktree, so they need to know where hooks ran).
    ///
    /// `extra_vars`: Additional template variables (e.g., `base`, `base_worktree_path`).
    pub fn execute_post_create_commands(&self, extra_vars: &[(&str, &str)]) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;
        super::hooks::run_hook_with_filter(
            self,
            self.config.hooks.post_create.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_create.as_ref()),
            HookType::PostCreate,
            extra_vars,
            HookFailureStrategy::Warn,
            None,
            crate::output::post_hook_display_path(self.worktree_path),
        )
    }

    /// Spawn post-start commands in parallel as background processes (non-blocking)
    ///
    /// `extra_vars`: Additional template variables (e.g., `base`, `base_worktree_path`).
    /// `display_path`: When `Some`, shows the path in hook announcements. Pass this when
    /// the user's shell won't be in the worktree (shell integration not active).
    pub fn spawn_post_start_commands(
        &self,
        extra_vars: &[(&str, &str)],
        display_path: Option<&std::path::Path>,
    ) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;

        let commands = prepare_hook_commands(
            self,
            self.config.hooks.post_start.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_start.as_ref()),
            HookType::PostStart,
            extra_vars,
            None,
            display_path,
        )?;

        spawn_hook_commands_background(self, commands, HookType::PostStart)
    }

    /// Spawn post-switch commands in parallel as background processes (non-blocking)
    ///
    /// Runs on every switch, including to existing worktrees and newly created ones.
    ///
    /// `extra_vars`: Additional template variables (e.g., `base`, `base_worktree_path`).
    /// `display_path`: When `Some`, shows the path in hook announcements. Pass this when
    /// the user's shell won't be in the worktree (shell integration not active).
    pub fn spawn_post_switch_commands(
        &self,
        extra_vars: &[(&str, &str)],
        display_path: Option<&std::path::Path>,
    ) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;

        let commands = prepare_hook_commands(
            self,
            self.config.hooks.post_switch.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_switch.as_ref()),
            HookType::PostSwitch,
            extra_vars,
            None,
            display_path,
        )?;

        spawn_hook_commands_background(self, commands, HookType::PostSwitch)
    }
}

/// Push changes to target branch
///
/// The `operations` parameter indicates which merge operations occurred (commit, squash, rebase).
/// Pass `None` for standalone push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    verb: &str,
    operations: Option<MergeOperations>,
) -> anyhow::Result<()> {
    let repo = Repository::current()?;

    // Get and validate target branch (must be a branch since we're updating it)
    let target_branch = repo.require_target_branch(target)?;

    // A worktree for the target branch is optional for push:
    // - If present, we use it to check for overlapping dirty files.
    // - If absent, we skip that safety step but still allow the push (git itself is fine).
    let target_worktree_path = repo.worktree_for_branch(&target_branch)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.clone(),
            commits_formatted,
            in_merge_context: operations.is_some(),
        }
        .into());
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    // The stash guard auto-restores on drop (error paths), or explicitly via restore_now()
    let mut stash_guard =
        repo.prepare_target_worktree(target_worktree_path.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context
        if let Some(ops) = operations {
            let mut skipped_ops = Vec::new();
            if !ops.committed && !ops.squashed {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !ops.rebased {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::print(progress_message(cformat!(
            "{verb_ing} {commit_count} {commit_text} to <bold>{target_branch}</> @ <dim>{head_sha}</>{operations_note}"
        )))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::print(format_with_gutter(&log_output, None))?;

        // Show diff statistics
        super::show_diffstat(&repo, &format!("{}..HEAD", target_branch))?;
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir();
    let git_common_dir_str = git_common_dir.to_string_lossy();

    // Perform the push - stash guard will auto-restore on any exit path
    // Use --receive-pack to pass config to the receiving end without permanently mutating repo config
    let push_target = format!("HEAD:{}", target_branch);
    repo.run_command(&[
        "push",
        "--receive-pack=git -c receive.denyCurrentBranch=updateInstead receive-pack",
        git_common_dir_str.as_ref(),
        &push_target,
    ])
    .map_err(|e| {
        // CommandFailed contains raw git output, wrap in PushFailed for proper formatting
        GitError::PushFailed {
            target_branch: target_branch.clone(),
            error: e.to_string(),
        }
    })?;

    // Restore stash before success message (Drop handles error paths automatically)
    if let Some(guard) = stash_guard.as_mut() {
        guard.restore_now();
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        // Re-apply bright-black after stats (which end with a reset) so ) is also gray
        let stats_str = summary_parts.join(", ");
        let paren_close = cformat!("<bright-black>)</>"); // Separate to avoid cformat optimization
        crate::output::print(success_message(cformat!(
            "{verb} <bold>{target_branch}</> <bright-black>({stats_str}</>{}",
            paren_close
        )))?;
    } else {
        // For merge workflow context, explain why nothing was pushed
        let context = if let Some(ops) = operations {
            let mut notes = Vec::new();
            if !ops.committed && !ops.squashed {
                notes.push("no new commits");
            }
            if !ops.rebased {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            String::new()
        };

        // No action: nothing was pushed, just acknowledging state
        crate::output::print(info_message(cformat!(
            "Already up to date with <bold>{target_branch}</>{context}"
        )))?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_switch_result_path_already_at() {
        let path = PathBuf::from("/test/path");
        let result = SwitchResult::AlreadyAt(path.clone());
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_path_existing() {
        let path = PathBuf::from("/test/existing");
        let result = SwitchResult::Existing(path.clone());
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_path_created() {
        let path = PathBuf::from("/test/created");
        let result = SwitchResult::Created {
            path: path.clone(),
            created_branch: true,
            base_branch: Some("main".to_string()),
            base_worktree_path: Some("/test/main".to_string()),
            from_remote: None,
        };
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_created_with_remote() {
        let path = PathBuf::from("/test/remote");
        let result = SwitchResult::Created {
            path: path.clone(),
            created_branch: false,
            base_branch: None,
            base_worktree_path: None,
            from_remote: Some("origin/feature".to_string()),
        };
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_merge_operations_struct() {
        let ops = MergeOperations {
            committed: true,
            squashed: false,
            rebased: true,
        };
        assert!(ops.committed);
        assert!(!ops.squashed);
        assert!(ops.rebased);
    }

    #[test]
    fn test_merge_operations_clone() {
        let ops = MergeOperations {
            committed: true,
            squashed: true,
            rebased: false,
        };
        // MergeOperations implements both Clone and Copy
        // Use Clone explicitly to test the Clone impl
        let cloned = Clone::clone(&ops);
        assert_eq!(ops.committed, cloned.committed);
        assert_eq!(ops.squashed, cloned.squashed);
        assert_eq!(ops.rebased, cloned.rebased);
    }

    #[test]
    fn test_merge_operations_copy() {
        let ops = MergeOperations {
            committed: false,
            squashed: false,
            rebased: true,
        };
        let copied = ops; // Copy trait
        assert_eq!(ops.committed, copied.committed);
        assert_eq!(ops.squashed, copied.squashed);
        assert_eq!(ops.rebased, copied.rebased);
    }

    #[test]
    fn test_merge_operations_debug() {
        let ops = MergeOperations {
            committed: true,
            squashed: false,
            rebased: true,
        };
        let debug = format!("{:?}", ops);
        assert!(debug.contains("committed: true"));
        assert!(debug.contains("squashed: false"));
        assert!(debug.contains("rebased: true"));
    }

    #[test]
    fn test_remove_result_removed_worktree() {
        let result = RemoveResult::RemovedWorktree {
            main_path: PathBuf::from("/main"),
            worktree_path: PathBuf::from("/worktree"),
            changed_directory: true,
            branch_name: Some("feature".to_string()),
            deletion_mode: BranchDeletionMode::SafeDelete,
            target_branch: Some("main".to_string()),
            integration_reason: Some(worktrunk::git::IntegrationReason::SameCommit),
            force_worktree: false,
            expected_path: None,
        };
        match result {
            RemoveResult::RemovedWorktree {
                main_path,
                worktree_path,
                changed_directory,
                branch_name,
                deletion_mode,
                target_branch,
                integration_reason,
                force_worktree,
                expected_path,
            } => {
                assert_eq!(main_path.to_str().unwrap(), "/main");
                assert_eq!(worktree_path.to_str().unwrap(), "/worktree");
                assert!(changed_directory);
                assert_eq!(branch_name.as_deref(), Some("feature"));
                assert!(!deletion_mode.should_keep());
                assert!(!deletion_mode.is_force());
                assert_eq!(target_branch.as_deref(), Some("main"));
                assert!(integration_reason.is_some());
                assert!(!force_worktree);
                assert!(expected_path.is_none());
            }
            _ => panic!("Expected RemovedWorktree variant"),
        }
    }

    #[test]
    fn test_remove_result_branch_only() {
        let result = RemoveResult::BranchOnly {
            branch_name: "stale-branch".to_string(),
            deletion_mode: BranchDeletionMode::Keep,
        };
        match result {
            RemoveResult::BranchOnly {
                branch_name,
                deletion_mode,
            } => {
                assert_eq!(branch_name, "stale-branch");
                assert!(deletion_mode.should_keep());
                assert!(!deletion_mode.is_force());
            }
            _ => panic!("Expected BranchOnly variant"),
        }
    }

    #[test]
    fn test_remove_result_with_force_delete() {
        let result = RemoveResult::RemovedWorktree {
            main_path: PathBuf::from("/main"),
            worktree_path: PathBuf::from("/worktree"),
            changed_directory: false,
            branch_name: None, // Detached HEAD
            deletion_mode: BranchDeletionMode::ForceDelete,
            target_branch: None,
            integration_reason: None, // Force delete skips integration check
            force_worktree: true,
            expected_path: None,
        };
        match result {
            RemoveResult::RemovedWorktree {
                branch_name,
                deletion_mode,
                force_worktree,
                ..
            } => {
                assert!(branch_name.is_none());
                assert!(deletion_mode.is_force());
                assert!(force_worktree);
            }
            _ => panic!("Expected RemovedWorktree variant"),
        }
    }

    #[test]
    fn test_generate_backup_path_with_extension() {
        // Paths with extensions: file.txt -> file.txt.bak.TIMESTAMP
        let path = PathBuf::from("/tmp/repo.feature");
        let backup = super::generate_backup_path(&path, "20250101-000000").unwrap();
        assert_eq!(
            backup,
            PathBuf::from("/tmp/repo.feature.bak.20250101-000000")
        );

        let path = PathBuf::from("/tmp/file.txt");
        let backup = super::generate_backup_path(&path, "20250101-000000").unwrap();
        assert_eq!(backup, PathBuf::from("/tmp/file.txt.bak.20250101-000000"));
    }

    #[test]
    fn test_generate_backup_path_without_extension() {
        // Paths without extensions: foo -> foo.bak.TIMESTAMP
        let path = PathBuf::from("/tmp/repo/feature");
        let backup = super::generate_backup_path(&path, "20250101-000000").unwrap();
        assert_eq!(
            backup,
            PathBuf::from("/tmp/repo/feature.bak.20250101-000000")
        );

        let path = PathBuf::from("/tmp/mydir");
        let backup = super::generate_backup_path(&path, "20250101-000000").unwrap();
        assert_eq!(backup, PathBuf::from("/tmp/mydir.bak.20250101-000000"));
    }

    #[test]
    fn test_generate_backup_path_unusual_paths() {
        // Root path has no file name
        let path = PathBuf::from("/");
        assert!(super::generate_backup_path(&path, "20250101-000000").is_err());

        // Parent reference has no file name
        let path = PathBuf::from("..");
        assert!(super::generate_backup_path(&path, "20250101-000000").is_err());
    }
}
