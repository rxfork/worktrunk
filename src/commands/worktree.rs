//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! Run `wt config shell install` to enable automatic cd
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt config shell init bash)"`), the shell function
//! intercepts commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary streams user-facing messages to **stderr** (real-time feedback)
//! 3. At exit, binary outputs a shell script to **stdout** (e.g., `cd '/path/to/worktree'`)
//! 4. Shell wrapper captures stdout via `$()` and evals it in the parent shell
//!
//! The binary **never changes directories itself** - it just outputs a shell script that the
//! wrapper evals to perform the cd.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag.
//!
//! ## Shell Script Protocol
//!
//! In directive mode (`--internal`), the binary:
//! - Streams all user messages to **stderr** (real-time, with colors)
//! - Buffers cd/exec directives internally
//! - At exit, emits a shell script to **stdout**:
//!
//! ```bash
//! cd '/path/to/worktree'
//! echo 'optional follow-up command'
//! ```
//!
//! The shell wrapper captures this via command substitution and evals it:
//!
//! ```bash
//! wt() {
//!     local script
//!     script="$("${_WORKTRUNK_CMD:-wt}" --internal "$@" 2>&2)" || {
//!         local status=$?
//!         [ -n "$script" ] && eval "$script"
//!         return "$status"
//!     }
//!     eval "$script"
//! }
//! ```
//!
//! This pattern (stderr for logs, stdout for script) is proven by direnv. Benefits:
//! - No FIFOs, no background processes, no job control suppression
//! - Full streaming: stderr goes directly to terminal while wt runs
//! - Simple shell wrapper: just command substitution + eval
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **If wt operation fails**: Returns wt's exit code (command never executes)
//! - **If wt succeeds but command fails**: Returns the command's exit code
//! - **Rationale**: Enables command chaining with proper error propagation
//!
//! Example:
//! ```bash
//! wt switch feature -x "cargo build" && cargo test
//! # If wt fails (e.g., worktree doesn't exist), cargo build never runs
//! # If cargo build fails, cargo test doesn't run (exit code propagates)
//! ```
//!
//! The shell wrapper is generated by `wt config shell init <shell>` from templates in `templates/`.

use anyhow::{Context, bail};
use std::path::PathBuf;
use worktrunk::HookType;
use worktrunk::config::{CommandPhase, WorktrunkConfig};
use worktrunk::git::{
    Repository, branch_already_exists, is_command_not_approved, merge_commits_found,
    not_fast_forward, push_failed, worktree_creation_failed, worktree_missing,
    worktree_path_exists, worktree_path_occupied,
};
use worktrunk::styling::{
    AnstyleStyle, CYAN, CYAN_BOLD, GREEN, GREEN_BOLD, WARNING, format_with_gutter,
};

use super::command_executor::CommandContext;
use super::hooks::{HookFailureStrategy, HookPipeline};
use super::repository_ext::RepositoryCliExt;

/// Flags indicating which merge operations occurred
#[derive(Debug, Clone, Copy)]
pub struct MergeOperations {
    pub committed: bool,
    pub squashed: bool,
    pub rebased: bool,
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Already at the target worktree (no action taken)
    AlreadyAt(PathBuf),
    /// Switched to existing worktree at the given path
    Existing(PathBuf),
    /// Created new worktree at the given path
    Created {
        path: PathBuf,
        created_branch: bool,
        base_branch: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::AlreadyAt(path) => path,
            SwitchResult::Existing(path) => path,
            SwitchResult::Created { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Removed worktree and returned to main (if needed)
    RemovedWorktree {
        main_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        branch_name: String,
        no_delete_branch: bool,
        force_delete: bool,
        target_branch: Option<String>,
    },
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<(SwitchResult, String)> {
    let repo = Repository::current();

    // Get current history (current, previous) before resolving
    let history_before = repo.get_switch_history();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo.resolve_worktree_name(branch)?;

    // Calculate what to record in history after the switch
    // History stores (current_location, previous_location) for ping-pong behavior
    let (new_current, new_previous) = if branch == "-" {
        // Switching back: swap current and previous
        // history_before contains (A, B), we're switching from A to B
        // After switch, record (B, A) so we can switch back to A
        if let Some(history) = history_before {
            (resolved_branch.clone(), Some(history.current))
        } else {
            // No history - shouldn't happen since "-" requires history
            // But handle gracefully: just record where we're going
            (resolved_branch.clone(), None)
        }
    } else {
        // Normal switch: record new location as current, old current as previous
        let previous = history_before.map(|h| h.current);
        (resolved_branch.clone(), previous)
    };

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(branch_already_exists(&resolved_branch));
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::warning(format!(
            "{WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        ))?;
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Record successful switch in history for `wt switch -` support
            let _ = repo.record_switch_history(&new_current, new_previous.as_deref());

            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);

            // Check if we're already at this worktree
            let current_dir = std::env::current_dir()
                .ok()
                .and_then(|p| p.canonicalize().ok());

            let already_at_worktree = current_dir
                .as_ref()
                .map(|cur| cur == &canonical_existing_path)
                .unwrap_or(false);

            return Ok((
                if already_at_worktree {
                    SwitchResult::AlreadyAt(canonical_existing_path)
                } else {
                    SwitchResult::Existing(canonical_existing_path)
                },
                resolved_branch,
            ));
        }
        Some(_) => {
            return Err(worktree_missing(&resolved_branch));
        }
        None => {}
    }

    // No existing worktree, create one (or reuse target path if available)
    let repo_root = repo.worktree_base()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("{}", "Invalid repository path"))?
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("{}", "Invalid UTF-8 in path"))?;

    let worktree_path = repo_root.join(
        config
            .format_path(repo_name, &resolved_branch)
            .map_err(|e| anyhow::anyhow!(format!("Failed to format worktree path: {}", e)))?,
    );

    // If the target path already exists but no worktree is registered for this branch,
    // surface a helpful error instead of letting git fail with "already exists".
    if repo.worktree_for_branch(&resolved_branch)?.is_none() && worktree_path.exists() {
        let occupant = Repository::at(&worktree_path)
            .current_branch()
            .ok()
            .flatten();
        bail!(
            "{}",
            worktree_path_occupied(&resolved_branch, &worktree_path, occupant.as_deref())
        );
    }

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => Some(repo.resolve_target_branch(None)?),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        let msg = e.to_string();
        // Check if error is about directory already existing
        if msg.contains("already exists") {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                let path = std::path::PathBuf::from(path_str);
                // Canonicalize if possible, otherwise use as-is
                let normalized_path = path.canonicalize().unwrap_or(path);
                return Err(worktree_path_exists(&normalized_path));
            }
        }
        // Fall back to generic error with context
        bail!(
            "{}",
            worktree_creation_failed(&resolved_branch, base_for_creation.as_deref(), &msg)
        );
    }

    // Canonicalize the path to resolve any .. components
    let worktree_path = worktree_path
        .canonicalize()
        .context("Failed to canonicalize worktree path")?;

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify {
        let repo_root = repo.worktree_base()?;
        let ctx = CommandContext::new(
            &repo,
            config,
            &resolved_branch,
            &worktree_path,
            &repo_root,
            force,
        );
        if let Err(e) = ctx.execute_post_create_commands() {
            // Only treat CommandNotApproved as non-fatal (user declined)
            // Other errors should still fail
            if is_command_not_approved(&e) {
                crate::output::info("Commands declined, continuing worktree creation")?;
            } else {
                return Err(e);
            }
        }
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    // Record successful switch in history for `wt switch -` support
    let _ = repo.record_switch_history(&new_current, new_previous.as_deref());

    Ok((
        SwitchResult::Created {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
        },
        resolved_branch,
    ))
}

pub fn handle_remove(
    worktree_name: &str,
    no_delete_branch: bool,
    force_delete: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        let progress_msg = format!(
            "{CYAN}Removing worktree for {CYAN_BOLD}{worktree_name}{CYAN_BOLD:#}{CYAN}...{CYAN:#}"
        );
        crate::output::progress(progress_msg)?;
    }

    repo.remove_worktree_by_name(worktree_name, no_delete_branch, force_delete)
}

impl<'a> CommandContext<'a> {
    /// Execute post-create commands sequentially (blocking)
    pub fn execute_post_create_commands(&self) -> anyhow::Result<()> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_create_config) = &project_config.post_create else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.run_sequential(
            post_create_config,
            CommandPhase::PostCreate,
            false,
            &[],
            "post-create",
            HookType::PostCreate,
            HookFailureStrategy::Warn,
        )
    }

    /// Spawn post-start commands in parallel as background processes (non-blocking)
    pub fn spawn_post_start_commands(&self) -> anyhow::Result<()> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_start_config) = &project_config.post_start else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.spawn_detached(
            post_start_config,
            CommandPhase::PostStart,
            false,
            &[],
            "post-start",
        )
    }

    /// Execute post-start commands sequentially (blocking) - for testing
    pub fn execute_post_start_commands_sequential(&self) -> anyhow::Result<()> {
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_start_config) = &project_config.post_start else {
            return Ok(());
        };

        let pipeline = HookPipeline::new(*self);
        pipeline.run_sequential(
            post_start_config,
            CommandPhase::PostStart,
            false,
            &[],
            "post-start",
            HookType::PostStart,
            HookFailureStrategy::Warn,
        )
    }
}

/// Push changes to target branch
///
/// The `operations` parameter indicates which merge operations occurred (commit, squash, rebase).
/// Pass `None` for standalone push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    allow_merge_commits: bool,
    verb: &str,
    operations: Option<MergeOperations>,
) -> anyhow::Result<()> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // A worktree for the target branch is optional for push:
    // - If present, we use it to check for overlapping dirty files.
    // - If absent, we skip that safety step but still allow the push (git itself is fine).
    let target_worktree_path = repo.worktree_for_branch(&target_branch)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        bail!("{}", not_fast_forward(&target_branch, &commits_formatted));
    }

    // Check for merge commits unless allowed
    let has_merge_commits = repo.has_merge_commits(&target_branch, "HEAD")?;
    if !allow_merge_commits && has_merge_commits {
        return Err(merge_commits_found());
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    let mut target_worktree_stash =
        repo.prepare_target_worktree(target_worktree_path.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        let cyan_dim = CYAN.dimmed();

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context
        if let Some(ops) = operations {
            let mut skipped_ops = Vec::new();
            if !ops.committed && !ops.squashed {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !ops.rebased {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        // Flag acknowledgments
        if allow_merge_commits && has_merge_commits {
            notes.push("merge commits allowed".to_string());
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::progress(format!(
            "{CYAN}{verb_ing} {commit_count} {commit_text} to {CYAN_BOLD}{target_branch}{CYAN_BOLD:#}{CYAN} @ {cyan_dim}{head_sha}{cyan_dim:#}{CYAN:#}{operations_note}"
        ))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::gutter(format_with_gutter(&log_output, "", None))?;

        // Show diff statistics
        super::show_diffstat(&repo, &format!("{}..HEAD", target_branch))?;
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    // Use --receive-pack to pass config to the receiving end without permanently mutating repo config
    let push_target = format!("HEAD:{}", target_branch);
    if let Err(e) = repo.run_command(&[
        "push",
        "--receive-pack=git -c receive.denyCurrentBranch=updateInstead receive-pack",
        git_common_dir.to_str().unwrap(),
        &push_target,
    ]) {
        if let Some(stash) = target_worktree_stash.take() {
            stash.restore()?;
        }
        // CommandFailed contains raw git output, wrap in PushFailed for proper formatting
        return Err(push_failed(&e.to_string()));
    }

    if let Some(stash) = target_worktree_stash.take() {
        stash.restore()?;
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#} ({})",
            summary_parts.join(", ")
        ))?;
    } else {
        // No commits to push - state description without action verb
        let bold = AnstyleStyle::new().bold();

        // For merge workflow context, explain why nothing was pushed
        let context = if let Some(ops) = operations {
            let mut notes = Vec::new();
            if !ops.committed && !ops.squashed {
                notes.push("no new commits");
            }
            if !ops.rebased {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            String::new()
        };

        // No action: nothing was pushed, just acknowledging state
        crate::output::info(format!(
            "Already up to date with {bold}{target_branch}{bold:#}{context}"
        ))?;
    }

    Ok(())
}
