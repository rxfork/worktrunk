---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - config
    - shell
    - init
    - bash
  env:
    CLICOLOR_FORCE: "1"
    COLUMNS: "150"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: "[TEST_GIT_CONFIG]"
    GIT_CONFIG_SYSTEM: /dev/null
    GIT_EDITOR: ""
    LANG: C
    LC_ALL: C
    SOURCE_DATE_EPOCH: "1761609600"
    WORKTRUNK_CONFIG_PATH: "[TEST_CONFIG]"
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for bash

# Only initialize if wt is available (in PATH or via WORKTRUNK_BIN)
if command -v wt >/dev/null 2>&1 || [[ -n "${WORKTRUNK_BIN:-}" ]]; then
    # Use WORKTRUNK_BIN if set, otherwise resolve binary path
    # Must resolve BEFORE defining shell function, so lazy completion can call binary directly
    # This allows testing development builds: export WORKTRUNK_BIN=./target/debug/wt
    _WORKTRUNK_CMD="${WORKTRUNK_BIN:-$(command -v wt)}"

# Simple shell integration for POSIX shells (bash, zsh).
#
# Captures the shell script from wt's stdout and evals it in the parent shell.
# stderr streams directly to the terminal for real-time user feedback.
#
# This pattern (stderr for logs, stdout for script) is proven by direnv.
# No FIFOs, no background processes, no job control suppression needed.
#
# Set WORKTRUNK_BIN to test development builds: WORKTRUNK_BIN=./target/debug/wt
wt_exec() {
    local script exit_code=0

    # Run wt with stderr attached to terminal (2>&2)
    # Capture stdout (the shell script) into $script
    script="$(command "${WORKTRUNK_BIN:-wt}" "$@" 2>&2)" || exit_code=$?

    # Eval the script (cd, exec command, etc.) even on failure
    # This ensures cd happens before returning the error code
    if [[ -n "$script" ]]; then
        eval "$script"
        # If script contains a command (--execute), use its exit code
        if [[ $exit_code -eq 0 ]]; then
            exit_code=$?
        fi
    fi

    return "$exit_code"
}

    # Override wt command to add --internal flag
    wt() {
        # Initialize _WORKTRUNK_CMD if not set (e.g., after shell snapshot restore)
        if [[ -z "$_WORKTRUNK_CMD" ]]; then
            _WORKTRUNK_CMD="${WORKTRUNK_BIN:-$(command -v wt)}"
        fi

        local use_source=false
        local args=()
        local saved_cmd="$_WORKTRUNK_CMD"

        # Check for --source flag and strip it
        for arg in "$@"; do
            if [[ "$arg" == "--source" ]]; then
                use_source=true
            else
                args+=("$arg")
            fi
        done

        # If --source was specified, build and use local debug binary
        if [[ "$use_source" == true ]]; then
            if ! cargo build --quiet; then
                _WORKTRUNK_CMD="$saved_cmd"
                return 1
            fi
            _WORKTRUNK_CMD="./target/debug/wt"
        fi

        # Force colors if stderr is a TTY (directive mode outputs to stderr)
        # Respects NO_COLOR and explicit CLICOLOR_FORCE
        if [[ -z "${NO_COLOR:-}" && -z "${CLICOLOR_FORCE:-}" ]]; then
            if [[ -t 2 ]]; then export CLICOLOR_FORCE=1; fi
        fi

        # Always use --internal mode for directive support
        wt_exec --internal "${args[@]}"

        # Restore original command
        local result=$?
        _WORKTRUNK_CMD="$saved_cmd"
        return $result
    }

    # Lazy completions - generate on first TAB, then delegate to clap's completer
    _wt_lazy_complete() {
        # Generate completions function once (check if clap's function exists)
        if ! declare -F _clap_complete_wt >/dev/null; then
            eval "$(COMPLETE=bash "$_WORKTRUNK_CMD" 2>/dev/null)" || return
        fi
        _clap_complete_wt "$@"
    }

    complete -o nospace -o bashdefault -F _wt_lazy_complete wt
fi

----- stderr -----
